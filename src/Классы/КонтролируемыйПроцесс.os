// Лог
Перем Лог;
// Каталог куда записываем информацию о контроле запущенного приложения
Перем КаталогКонтроляОткрытыхПриложений;

#Область ПрограммныйИнтерфейс

Процедура ЗапуститьПроцесс1С(Знач СтрокаЗапуска, Знач ПутьКФайлуЛога) Экспорт

	ПериодОпросаВМиллисекундах = 1000;

	НадоЧитатьЛог = Истина;
	КолСтрокЛогаПрочитано = 0;

	Процесс = СоздатьПроцесс(СтрокаЗапуска);
	Процесс.Запустить();

	ТаймаутПоУмолчанию = 3000;
	Приостановить(ТаймаутПоУмолчанию);

	Идентификатор = Процесс.Идентификатор;
	ЗаписатьИнформациюОЗапуске(СтрокаЗапуска, Идентификатор);

	Пока НЕ Процесс.Завершен Цикл

		Если ПериодОпросаВМиллисекундах <> 0 Тогда
			Приостановить(ПериодОпросаВМиллисекундах);
		КонецЕсли;

		Если НадоЧитатьЛог Тогда
			ВывестиНовыеСообщения(ПутьКФайлуЛога, КолСтрокЛогаПрочитано);
		КонецЕсли;

	КонецЦикла;

КонецПроцедуры

// Запускает приложение и ожидает его выполнения (или нет)
//
// Параметры:
//	СтрокаЗапуска - Строка - командная строка
//	ОжидатьЗавершения - Булево - ожидать завершения процесса или нет
//
// Возвращаемое значение:
//	Структура - результат выполнения
//		* КодВозврата - Число - 0 ошибок нет, остальное код ошибки
//		* Результат - Строка - текст вывода лога
//
Функция ЗапуститьИПодождать(Знач СтрокаЗапуска, Знач ОжидатьЗавершения = Истина) Экспорт

	Процесс = СоздатьПроцесс(СтрокаЗапуска, "./", Истина, Истина);
	Попытка
		Процесс.Запустить();
	Исключение
		Если ПараметрыСистемы.ЭтоWindows Тогда
			ШаблонЗапуска = "cmd /c %1";
		Иначе
			ШаблонЗапуска = "sh -c '%1'";
		КонецЕсли;
		Процесс = СоздатьПроцесс(СтрШаблон(ШаблонЗапуска, СтрокаЗапуска), "./", Истина, Истина);
		Процесс.Запустить();
	КонецПопытки;

	Идентификатор = Процесс.Идентификатор;
	ЗаписатьИнформациюОЗапуске(СтрокаЗапуска, Идентификатор);

	Если ОжидатьЗавершения = Ложь Тогда
		Возврат Новый Структура("КодВозврата, Результат, Процесс", 0, "", Процесс);
	КонецЕсли;

	ПаузаОжиданияЧтенияБуфера = 1000;
	Приостановить(ПаузаОжиданияЧтенияБуфера);

	Текст = Новый ТекстовыйДокумент;
	Пока Истина Цикл
		
		ВывестиДанныеПроцесса(Процесс, Текст);
		
		Если Процесс.Завершен Тогда
			Процесс.ОжидатьЗавершения(); // финальный сброс буферов
			ВывестиДанныеПроцесса(Процесс, Текст);
			Прервать;
		КонецЕсли;
		
		Приостановить(ПаузаОжиданияЧтенияБуфера);
		
	КонецЦикла;
	
	Возврат Новый Структура("КодВозврата, Результат, Процесс", 
		Процесс.КодВозврата, Текст.ПолучитьТекст(), Неопределено);

КонецФункции // ЗапуститьИПодождать(СтрокаЗапуска)

// Завершает работу приложения по PID
//
// Параметры:
//	Идентификатор - Число - PID процесса
//
Процедура ЗавершитьПроцессПоИдентификатору(Знач Идентификатор) Экспорт

	Процесс = НайтиПроцессПоИдентификатору(Идентификатор);
	Если ЗначениеЗаполнено(Процесс) Тогда
		Процесс.Завершить();
		Лог.Информация("Процесс с PID %1 найден и завершен", Идентификатор);
	Иначе
		Лог.Предупреждение("Процесс с PID %1 не найден и не может быть завершен", Идентификатор);
	КонецЕсли;
	
КонецПроцедуры

// Завершает работу процессов по имени
//
// Параметры:
//	ИмяПроцесса - Строка - имя процесса
//
Процедура ЗавершитьПроцессПоИмени(Знач ИмяПроцесса) Экспорт

	МассивПроцессов = НайтиПроцессыПоИмени(ИмяПроцесса);
	Для Каждого Процесс Из МассивПроцессов Цикл
		ЗавершитьПроцессПоИдентификатору(Процесс.Идентификатор);
	КонецЦикла;
	
КонецПроцедуры

#КонецОбласти

#Область ОбработчикиСобытий

Процедура ПриСозданииОбъекта(КаталогКонтроля = Неопределено)

	Лог = ПараметрыСистемы.Лог();
	КаталогКонтроляОткрытыхПриложений = КаталогКонтроля;

КонецПроцедуры

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

Процедура ЗаписатьИнформациюОЗапуске(Знач СтрокаЗапуска, Идентификатор)

	Если ЗначениеЗаполнено(КаталогКонтроляОткрытыхПриложений) Тогда
		ФайловыеОперации.ОбеспечитьКаталог(КаталогКонтроляОткрытыхПриложений);
		ИмяФайла = Строка(Новый УникальныйИдентификатор) + ".json";
		ИмяФайла = ОбъединитьПути(КаталогКонтроляОткрытыхПриложений, ИмяФайла);
		Структура = Новый Структура("Идентификатор, СтрокаЗапуска", Идентификатор, СтрокаЗапуска);
		РаботаJSON.ЗаписатьФайлJSON(ИмяФайла, Структура);
	КонецЕсли;

КонецПроцедуры

Процедура ВывестиНовыеСообщения(ИмяФайлаЛога, КолСтрокЛогаПрочитано)

	Попытка
		МассивСтрок = ПолучитьНовыеСтрокиЛога(ИмяФайлаЛога, КолСтрокЛогаПрочитано);
		Для Каждого Стр Из МассивСтрок Цикл
			СтрокаЛога = СокрЛП(Стр);			
			Если СтрокаЛога = "" Тогда
				Продолжить;
			КонецЕсли;
			Лог.Информация(СтрокаЛога);
		КонецЦикла;
	Исключение
		Лог.Ошибка(ОписаниеОшибки());
	КонецПопытки;

КонецПроцедуры

Функция ПолучитьНовыеСтрокиЛога(Знач ИмяФайла, КолСтрокЛогаПрочитано)

	Файл = Новый Файл(ИмяФайла);
	Если Не Файл.Существует() Тогда
		Возврат Новый Массив;
	КонецЕсли;

	Текст = Новый ЧтениеТекста;
	Текст.Открыть(ИмяФайла, "UTF-8", , , Ложь);

	ВесьТекст = Текст.Прочитать();

	Текст.Закрыть();

	Массив = Новый Массив();

	МассивСтрок = СтрРазделить(ВесьТекст, Символы.ПС, Истина);
	Если ЗначениеЗаполнено(МассивСтрок) Тогда
		КоличествоМинус1 = МассивСтрок.Количество() - 1;
		Если МассивСтрок[КоличествоМинус1] = "" Тогда
			МассивСтрок.Удалить(КоличествоМинус1);
		КонецЕсли;
	КонецЕсли;

	Для Индекс = (КолСтрокЛогаПрочитано + 1) По МассивСтрок.Количество() Цикл
		Массив.Добавить(МассивСтрок[Индекс - 1]);
	КонецЦикла;

	КолСтрокЛогаПрочитано = МассивСтрок.Количество();

	Возврат Массив;
КонецФункции

Процедура ВывестиДанныеПроцесса(Знач Процесс, Знач Приемник)

	Вывод = Процесс.ПотокВывода.Прочитать();
	Ошибки = Процесс.ПотокОшибок.Прочитать();
	Если СтрДлина(Строка(Вывод)) > 0 Тогда
		Лог.Информация(Вывод);
		Приемник.ДобавитьСтроку(Вывод);
	КонецЕсли;	
	Если СтрДлина(Строка(Ошибки)) > 0 Тогда
		Лог.Ошибка(Вывод);
		Приемник.ДобавитьСтроку(Ошибки);
	КонецЕсли;

КонецПроцедуры

#КонецОбласти